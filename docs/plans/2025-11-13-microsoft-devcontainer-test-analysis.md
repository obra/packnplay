# Microsoft devcontainer CLI Test Structure Analysis

## Overview
The Microsoft devcontainer CLI repository uses a TypeScript/JavaScript test suite built with **Mocha** (test framework) and **Chai** (assertions). The test suite is located in `/src/test/` with container-features tests in `/src/test/container-features/`.

### Test Framework Stack
- **Test Runner**: Mocha 11.1.0
- **Assertion Library**: Chai 4.5.0
- **TypeScript**: TypeScript + ts-node for runtime compilation
- **Test Script**: `npm run test-container-features`

---

## Test Directory Structure

### Main Test Directory
```
/src/test/container-features/
├── *.test.ts                          # Test files (11 files, 4,400 lines total)
├── testUtils.ts                       # Shared test utilities
├── assets/                            # Test assets
├── configs/                           # Test configuration directories (27 subdirs)
├── example-v2-features-sets/          # Example feature sets for testing (15 subdirs)
└── tmp*/                              # Temporary directories created during tests
```

### Example Feature Sets Directory
```
/src/test/container-features/example-v2-features-sets/
├── simple/                            # Basic features (color, hello)
├── autogenerated-set-flags/           # Testing autogenerated flags
├── a-installs-after-b/                # Testing installsAfter dependency
├── b-installs-after-a/                # Testing installsAfter order
├── lifecycle-hooks/                   # Testing lifecycle commands (onCreate, postCreate, etc.)
├── failing-test/                      # Testing failure scenarios
├── dockerfile-scenario-test/          # Testing Dockerfile scenarios
├── sharing-test-scripts/              # Testing shared test scripts
├── remote-user/                       # Testing remoteUser functionality
├── installs-after-advanced/           # Advanced installsAfter tests
├── renaming-feature/                  # Testing feature renaming
└── dependsOn-and-installsAfter/       # Combined dependency testing
```

### Test Configs Directory (27 configurations)
Contains real-world devcontainer configurations for testing:
- `feature-dependencies/` - Dependency resolution tests
- `lifecycle-hooks-inline-commands/` - Lifecycle hook tests
- `lifecycle-hooks-advanced/` - Advanced lifecycle tests
- `lifecycle-hooks-resume-existing-container/` - Resume behavior tests
- `lockfile-*/` - Lockfile-related configs (frozen, outdated, etc.)
- `dockerfile-with-v2-*-features/` - Dockerfile + features combinations
- `image-with-v2-tarball/` - Image with tarball features
- `registry-compatibility/` - Registry authentication & compatibility tests
- `invalid-configs/` - Invalid configuration scenarios

---

## Test Files (4,400 lines total)

### 1. **featuresCLICommands.test.ts** (703 lines)
**Purpose**: Tests the CLI commands for features

**Key Test Groups**:
- `features test` subcommand
  - Basic project folder testing
  - Remote user flag handling (`--remote-user`)
  - Shared test scripts functionality
  - Filtering tests (`--filter`)
  - Skipping autogenerated tests (`--skip-autogenerated`)
  - Global scenarios only (`--global-scenarios-only`)
  - Test failure reporting
  
- `features package` subcommand
  - Packaging by collection
  - Packaging single features
  - Tarball generation verification

- Helper functions (semantic versioning)
  - `getSemanticVersions()` - version tag generation
  - `getVersionsStrictSorted()` - published version listing
  - `generateFeaturesDocumentation()` - docs generation

**Test Utilities Used**:
- `shellExec()` - Run CLI commands
- Output validation via regex matching
- File existence checks

---

### 2. **containerFeaturesOrder.test.ts** (699 lines)
**Purpose**: Tests feature dependency resolution and installation ordering

**Key Test Groups**:
- **Feature Dependencies**
  - `installsAfter` ordering
    - Valid local file-path features
    - Invalid circular dependencies
    - Legacy ID backward compatibility
    - Multiple dependency scenarios
  
  - `dependsOn` ordering
    - Valid local file-path dependencies
    - Round sorting based on options
    - Hash-based stable ordering
    - Global scenarios handling

**Advanced Scenarios**:
- Multiple features with complex dependency graphs
- Hash-based deterministic ordering when dependencies are equal
- Legacy ID resolution (feature renames)

**Test Setup Pattern**:
```typescript
const { params, userFeatures, processFeature, config } = 
  await setupInstallOrderTest(testFolder);

const installOrderNodes = await 
  computeDependsOnInstallationOrder(params, processFeature, userFeatures, config);
```

---

### 3. **featureHelpers.test.ts** (925 lines)
**Purpose**: Tests feature identifier parsing and configuration

**Key Test Groups**:
- `getSafeId()` - Environment variable name generation
  - Dash to underscore conversion
  - Leading number handling
  - Capitalization rules
  
- `processFeatureIdentifier()` - Feature reference parsing
  - v1 local-cache features
  - GitHub repo references (with/without version)
  - Direct tarball URLs
  - OCI registry references
  - Local file-path features
  - Backward compatibility features

**Feature Source Types Tested**:
1. OCI Registry (ghcr.io/devcontainers/features/*)
2. GitHub Releases (owner/repo/feature@version)
3. Direct Tarball URLs
4. Local File Paths
5. Legacy/cached references

**Detailed Assertions**:
- Feature ID invariant validation (no slashes, colons, dots in ID)
- Source information structure verification
- Version/tag parsing
- API endpoint construction

---

### 4. **lifecycleHooks.test.ts** (461 lines)
**Purpose**: Tests feature lifecycle command execution

**Key Test Groups**:
- `lifecycle-hooks-inline-commands`
  - Marker file creation tests
  - Execution order verification (numbered sequence)
  - Hook stages:
    - onCreateCommand (phase 0, 1, 2)
    - updateContentCommand (phase 3, 4, 5)
    - postCreateCommand (phase 6, 7, 8)
    - postStartCommand (phase 9, 10, 11)
    - postAttachCommand (phase 12, 13, 14)
  
  - Container resume behavior
    - Restarting container re-runs postStart/postAttach
    - Preserves completed hook markers
    - postStartCommand fires on resume

- `lifecycle-hooks-inline-commands with secrets`
  - Secret injection in lifecycle hooks
  - Environment variable masking

- `lifecycle-hooks-advanced`
  - User context preservation
  - Remote user context switches

**Test Pattern**:
```typescript
const containerId = (await devContainerUp(cli, testFolder, options)).containerId;
const res = await shellExec(`${cli} exec --workspace-folder ${testFolder} ls -altr`);
// Verify marker files in order
```

---

### 5. **e2e.test.ts** (255 lines)
**Purpose**: End-to-end integration tests

**Key Test Groups**:
- Invalid configs detection
  - Non-existent v1 features
  - Non-existent v2 features
  - Error message validation

- Dockerfile + v2 OCI features
  - Docker installation verification
  - Privileged flag testing
  - Configuration reading with features
  - Customization merging (VSCode extensions, settings)

- Local features (v2)
  - Features inside .devcontainer folder
  - Features outside .devcontainer folder
  - Custom command execution
  - Feature customization reading

**Real-World Testing**:
- Creates actual containers
- Executes commands inside containers
- Validates output
- Cleans up resources

---

### 6. **generateFeaturesConfig.test.ts** (137 lines)
**Purpose**: Tests features configuration generation

**Key Test Groups**:
- Local v2 features configuration
  - Feature count verification
  - Feature ID extraction
  - Option value parsing
  - Feature layer generation (Dockerfile RUN commands)
  
- Customizations handling
  - VSCode extensions collection
  - Settings merging
  - Multi-feature customization
  - Built-in features (node, docker-in-docker, java)

**Generated Output Verification**:
- Layer count and structure
- Copy commands for feature content
- Permission setup
- Script execution

---

### 7. **containerFeaturesOCI.test.ts** (310 lines)
**Purpose**: Tests OCI registry reference handling

**Key Test Groups**:
- `getCollectionRef()` - Collection reference parsing
  - Valid references with/without ports
  - Case normalization (uppercase to lowercase)
  - Invalid character detection
  - Duplicate slash detection

- `getRef()` - Individual feature reference parsing
  - References with tags
  - References with digests
  - Short-hand notation
  - Version parsing
  - Digest vs tag distinction

**OCI Reference Structure Testing**:
- Registry extraction
- Path/namespace parsing
- Owner/repo resolution
- Resource URI construction

---

### 8. **containerFeaturesOCIPush.test.ts** (374 lines)
**Purpose**: Tests publishing features to OCI registries

**Key Test Groups**:
- Publishing to registry
  - Multiple features in collection
  - Tag generation (1, 1.0, 1.0.0, latest)
  - Digest calculation
  - Re-publishing (version conflict handling)

- Registry interaction
  - Registry startup (Docker registry container)
  - Authentication (basic auth with htpasswd)
  - Login/logout flow
  - Tag listing
  - Manifest verification

**Advanced Features**:
- Multiple publish rounds
- Version conflict detection
- Legacy ID publishing
- Deterministic digest calculation

---

### 9. **lockfile.test.ts** (260 lines)
**Purpose**: Tests lockfile functionality for reproducible builds

**Key Test Groups**:
- Basic lockfile generation
  - Write lockfile with `--experimental-lockfile`
  - Verify lockfile structure
  - Compare against expected output

- Lockfile with dependencies
  - installsAfter dependencies
  - dependsOn dependencies
  - Deterministic ordering

- Frozen lockfile
  - `--experimental-frozen-lockfile` flag
  - Prevents modifications
  - Enforces reproducibility

- Outdated detection
  - Lockfile vs current config comparison
  - Version mismatch detection
  - Update suggestions

- Command: `outdated`
  - JSON output format
  - Current/wanted/latest version tracking
  - Semantic versioning comparison

---

### 10. **featureAdvisories.test.ts** (104 lines)
**Purpose**: Tests feature security advisories

**Key Test Groups**:
- Version range matching
  - Features within advisory version range
  - Features at version boundaries
  - Features outside advisory range
  - Multiple version ranges

**Advisory Matching Logic**:
- Semantic version range checking
- Advisory fetching and caching
- Multi-feature advisory collection

---

### 11. **registryCompatibilityOCI.test.ts** (172 lines)
**Purpose**: Tests registry compatibility across different providers

**Key Test Groups**:
- Anonymous registry access
  - Azure Container Registry (anonymous)
  - GHCR (anonymous)
  - GHCR (feature-starter)

- Authenticated access
  - Azure Container Registry (registry-scoped tokens)
  - GitHub Container Registry (GitHub token auth)
  - Docker config auth file support

**Auth Strategies**:
1. Anonymous (no credentials)
2. GitHub Token (via GITHUB_TOKEN env var)
3. Docker Config Auth File (via DOCKER_CONFIG env var)

**Test Coverage**:
- Container startup with auth
- Command execution in container
- Feature info/manifest fetching with auth

---

## Shared Test Utilities (testUtils.ts)

### Core Functions

**Shell Execution**:
```typescript
shellExec(command, options?, suppressOutput?, doNotThrow?)
  - Returns: { error, stdout, stderr }
  - Handles command execution with optional output suppression
  - Can suppress exceptions for negative tests

shellBufferExec(command, options?)
  - Returns: { stdout: Buffer, stderr: Buffer, code, signal }
  - For binary/large output handling

shellPtyExec(command, options?)
  - PTY support for interactive commands
  - Handles terminal output properly
```

**Container Lifecycle**:
```typescript
devContainerUp(cli, workspaceFolder, options?)
  - Returns: { outcome, containerId, composeProjectName, stderr }
  - Options: cwd, useBuildKit, userDataFolder, logLevel, extraArgs, prefix, env
  - Assertions: outcome='success', containerId exists

devContainerDown(options)
  - Cleanup: removes container or docker-compose project

devContainerStop(options)
  - Stops (doesn't remove) container

pathExists(cli, workspaceFolder, location)
  - Checks file/directory existence in container

commandMarkerTests(cli, workspaceFolder, expected, message)
  - Verifies marker files for lifecycle command execution
  - Checks: postCreate, postStart, postAttach
```

**CLI Helpers**:
```typescript
createCLIParams(hostPath)
  - Constructs Docker CLI parameters for tests
  - Includes platform info mapping
  - Sets up docker-compose CLI

output
  - Shared logger instance (LogLevel.Trace)
  - Used for consistent logging across tests

testSubstitute
  - Configuration value substitution for testing
  - Appends '-substituted' to IDs
```

### Build Kit Options
```typescript
const buildKitOption = { text: 'BuildKit', options: { useBuildKit: true } };
const nonBuildKitOption = { text: 'non-BuildKit', options: { useBuildKit: false } };
const buildKitOptions = [nonBuildKitOption, buildKitOption];
```

Used for parameterized testing across build backends.

---

## Example Feature Set Structure

### Typical Feature Directory
```
simple/src/color/
├── devcontainer-feature.json
└── install.sh

devcontainer-feature.json:
{
    "id": "color",
    "version": "1.0.0",
    "name": "A feature to remind you of your favorite color",
    "options": {
        "favorite": {
            "type": "string",
            "enum": ["red", "gold", "green"],
            "default": "red",
            "description": "Choose your favorite color."
        }
    }
}

install.sh:
#!/bin/bash
# Feature installation logic
```

### Test Marker Patterns
```
test/devcontainer.json:
{
    "features": {
        "./color": { "favorite": "gold" },
        "./hello": {}
    }
}

test/color/test/test.sh:
#!/bin/bash
# Runs after installation
# Validates feature installation
# Exit code determines test pass/fail
```

---

## Test Patterns & Best Practices

### 1. Feature Testing Pattern
```typescript
describe('features test', () => {
    it('succeeds when using --project-folder', async () => {
        const collectionFolder = `${__dirname}/example-v2-features-sets/simple`;
        const result = await shellExec(
            `${cli} features test --project-folder ${collectionFolder} --base-image mcr.microsoft.com/devcontainers/base:ubuntu`
        );
        
        const expectedTestReport = `TEST REPORT ==================`;
        assert.match(result.stdout, expectedTestReport);
    });
});
```

### 2. Dependency Resolution Pattern
```typescript
const { params, userFeatures, processFeature, config } = 
    await setupInstallOrderTest(testFolder);

const installOrderNodes = await 
    computeDependsOnInstallationOrder(params, processFeature, userFeatures, config);

assert.deepStrictEqual(actual, [
    { userFeatureId: './c', options: { magicNumber: '321' } },
    { userFeatureId: './a', options: {} }
]);
```

### 3. E2E Container Testing Pattern
```typescript
let containerId: string | null = null;
beforeEach(async () => {
    containerId = (await devContainerUp(cli, testFolder, { logLevel: 'trace' })).containerId;
});
afterEach(async () => await devContainerDown({ containerId }));

it('should exec command', async () => {
    const res = await shellExec(`${cli} exec --workspace-folder ${testFolder} color`);
    assert.match(res.stdout, /my favorite color is gold/);
});
```

### 4. Lifecycle Hook Pattern
```typescript
const res = await shellExec(`${cli} exec --workspace-folder ${testFolder} ls -altr`);
assert.match(res.stdout, /0.panda.onCreateCommand.testMarker/);
assert.match(res.stdout, /3.panda.updateContentCommand.testMarker/);
assert.match(res.stdout, /6.panda.postCreateCommand.testMarker/);
```

### 5. Registry Authentication Pattern
```typescript
const authFolder = constructAuthFromStrategy(tmp, AuthStrategy.DockerConfigAuthFile, authKey);
const gitHubToken = (useAuthStrategy === AuthStrategy.GitHubToken) ? process.env.GITHUB_TOKEN : '';

const result = await devContainerUp(cli, testFolder, {
    logLevel: 'trace',
    prefix: `DOCKER_CONFIG=${authFolder} GITHUB_TOKEN=${gitHubToken}`
});
```

---

## Key Testing Concepts

### Feature Resolution Types
1. **OCI Registry**: `ghcr.io/devcontainers/features/docker-in-docker:1`
2. **GitHub Release**: `octocat/myfeatures/helloworld@v0.0.4`
3. **Direct Tarball**: `https://example.com/path/devcontainer-feature-ruby.tgz`
4. **Local File Path**: `./color`
5. **Legacy Short-hand**: `docker-in-docker` (auto-mapped to ghcr.io)

### Dependency Models
1. **installsAfter**: Feature must install after specified feature(s)
2. **dependsOn**: Feature depends on functionality in specified feature(s)
3. **Circular Dependencies**: Detected and rejected

### Lifecycle Stages
1. **onCreateCommand**: Runs during container creation
2. **updateContentCommand**: Runs after source code mount
3. **postCreateCommand**: Runs after container creation
4. **postStartCommand**: Runs on container start/resume
5. **postAttachCommand**: Runs on editor attach

### Test Execution Model
1. Container is built/created
2. Features are installed in dependency order
3. Test scripts are executed (if present)
4. Output is captured and validated
5. Container is optionally preserved or cleaned up

---

## Testing Infrastructure

### Temporary Directories
- `${__dirname}/tmp*` - CLI working directories
- Node modules installed via `npm install devcontainers-cli-*.tgz`
- Test outputs captured for validation

### Configuration Management
- `.devcontainer/devcontainer.json` - Config file
- `.devcontainer-lock.json` - Lockfile (optional)
- `devcontainer-feature.json` - Feature metadata

### Output Validation
- Regex pattern matching on stdout/stderr
- JSON parsing for structured output
- Exit codes for success/failure determination
- File existence checks in containers

### Timeouts
- Default: 120s per test
- Extended: 240s for full feature test suites
- 300s for remote E2E tests

---

## Configuration Examples

### Simple Feature Test Config
```json
{
    "features": {
        "./color": { "favorite": "gold" }
    }
}
```

### Multi-Feature with Dependencies
```json
{
    "features": {
        "ghcr.io/devcontainers/features/node:1": { "version": "20" },
        "ghcr.io/devcontainers/features/docker-in-docker:1": {},
        "./custom-feature": { "option": "value" }
    }
}
```

### With Lifecycle Commands
```json
{
    "features": { "node": { "version": "20" } },
    "onCreateCommand": "echo 'onCreate'",
    "postCreateCommand": "npm install",
    "postStartCommand": "echo 'postStart'",
    "postAttachCommand": "echo 'postAttach'"
}
```

---

## Summary Table

| Test File | Lines | Focus | Key Functions |
|-----------|-------|-------|----------------|
| featuresCLICommands.test.ts | 703 | CLI commands | features test/package |
| containerFeaturesOrder.test.ts | 699 | Dependency ordering | installsAfter, dependsOn |
| featureHelpers.test.ts | 925 | ID parsing | processFeatureIdentifier |
| lifecycleHooks.test.ts | 461 | Hook execution | Marker file verification |
| e2e.test.ts | 255 | Integration | Container building |
| generateFeaturesConfig.test.ts | 137 | Config generation | Dockerfile layers |
| containerFeaturesOCI.test.ts | 310 | OCI references | getRef, getCollectionRef |
| containerFeaturesOCIPush.test.ts | 374 | Registry push | Publishing, tagging |
| lockfile.test.ts | 260 | Lockfiles | Reproducible builds |
| featureAdvisories.test.ts | 104 | Advisories | Version matching |
| registryCompatibilityOCI.test.ts | 172 | Registry auth | Multiple auth strategies |

---

## Port Recommendations for packnplay

### High Priority Features to Port
1. **Feature resolution** (`processFeatureIdentifier` patterns)
2. **Dependency ordering** (`computeDependsOnInstallationOrder`)
3. **Lifecycle hook execution** (onCreateCommand, postCreateCommand, etc.)
4. **Option validation** (enum, type checking)
5. **Container feature installation** (Dockerfile layer generation)

### Recommended Test Structure
```
tests/
├── features/
│   ├── feature-resolution.test.go
│   ├── feature-ordering.test.go
│   ├── feature-options.test.go
│   ├── lifecycle-hooks.test.go
│   ├── e2e.test.go
│   └── fixtures/
│       ├── feature-sets/
│       └── configs/
└── utils/
    └── test-helpers.go
```

### Key Test Utilities to Create
1. Container execution wrapper (similar to `devContainerUp`)
2. Feature resolution resolver (similar to `processFeatureIdentifier`)
3. Dependency graph builder (similar to `computeDependsOnInstallationOrder`)
4. Lifecycle command executor
5. Feature option validator

